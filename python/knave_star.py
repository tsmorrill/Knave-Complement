from collections import namedtuple
from functools import reduce
from itertools import groupby, pairwise, product
from math import pow
from pprint import pprint
from random import choice

AUTHOR = 'Tamsyn Morrill'
TITLE = 'knave_star.py'
DESCRIPTION = "Let's have some knavery!"
VERSION = '0.4'

def compose(*funcs):
    if funcs == ():
        chain = lambda x: x
    else:
        head, *tail = funcs
        chain_t = compose(*tail)
        chain = lambda x: head(chain_t(x))
    return lambda x: chain(x)


def welcome():
    print(f'{AUTHOR} welcomes you to {TITLE}, v{VERSION}.')
    print('')
    print(DESCRIPTION)
    print('')


def oops():
    msg = choice(('Come again?',
                  "I didn't catch that.",
                  "Sorry, I'm only a simple script.",
                  "That's a typo.",
                  'Do me a solid and read those instructions again.',
                  'Are you doing this on purpose?',
                  "I'm a state machine, not a language model.",
                  "Honestly, I'm more of a parsnip than a parser.",
                  "Just how much spare time do you think Tammy put into these Easter Eggs?"))
    print(msg)


def pick(msg:str, options:tuple):
    if msg != '':
        print(msg)
    verbose = (f'    {i}: {opt}' for i, opt in enumerate(options))
    for line in verbose:
        print(line)
    selection = None
    while selection is None:
        try:
            i = int(input())
            selection = options[i]
        except:
            oops()
    print('')
    return selection


MODES = ('Knave Map',
         'Knave* Map',
         'Iterate w/ Stats',
         'Translation Dicitionary')


def set_mode():
    return pick('Select mode:', MODES)


def run_length(data: str):
    return ((sum(1 for _ in y), x) for x, y in groupby(data))


def knave_run(pair):
    run, char = pair
    lie = {'0': '1', '1': '0'}
    return '{0:b}'.format(run) + lie[char]


def knave(word:str):
    pairs = tuple(run_length(word))
    desc = reduce(lambda x, y: x+y, map(knave_run, pairs), '')
    return desc


# lookup tables generated by helper.py

bond = {
        '|': '|',
        '.': '',
        '?': '',
        '!': '',
        ',': '',
        ';': '',
        'a': '?',
        'b': '.',
        'c': '!',
        'd': '.',
        'e': '?',
        'f': '.',
        'g': '!',
        'h': '?',
        'i': '.',
        'j': '!',
        'k': '?',
        'l': '.',
        'm': '!',
        'n': '?',
}

desc_pipe = {
          '|': '||',
          '.': '|a',
          '?': '|b',
          '!': '|e',
          ',': '|c',
          ';': '|aa',
          'a': '|a',
          'b': '|aa',
          'c': '|a',
          'd': '|ab',
          'e': '|b',
          'f': '|ba',
          'g': '|b',
          'h': '|e',
          'i': '|ea',
          'j': '|e',
          'k': '|c',
          'l': '|ca',
          'm': '|c',
          'n': '|aa',
}

desc_stop = {
          'a': 'b',
          'b': 'ba',
          'c': 'b',
          'd': 'bb',
          'e': 'e',
          'f': 'ea',
          'g': 'e',
          'h': 'c',
          'i': 'ca',
          'j': 'c',
          'k': 'aa',
          'l': 'aaa',
          'm': 'aa',
          'n': 'f',
          '|': '|',
}

desc_orly = {
          'a': 'e',
          'b': 'ea',
          'c': 'e',
          'd': 'eb',
          'e': 'c',
          'f': 'ca',
          'g': 'c',
          'h': 'aa',
          'i': 'aaa',
          'j': 'aa',
          'k': 'f',
          'l': 'fa',
          'm': 'f',
          'n': 'h',
          '|': '|',
}

desc_bang = {
          'a': 'c',
          'b': 'ca',
          'c': 'c',
          'd': 'cb',
          'e': 'aa',
          'f': 'aaa',
          'g': 'aa',
          'h': 'f',
          'i': 'fa',
          'j': 'f',
          'k': 'h',
          'l': 'ha',
          'm': 'h',
          'n': 'd',
          '|': '|',
}

desc_coma = {
          'a': 'aa',
          'b': 'aaa',
          'c': 'aa',
          'd': 'aab',
          'e': 'f',
          'f': 'fa',
          'g': 'f',
          'h': 'h',
          'i': 'ha',
          'j': 'h',
          'k': 'd',
          'l': 'da',
          'm': 'd',
          'n': 'ba',
          '|': '|',
}

desc_semi = {
          'a': 'f',
          'b': 'fa',
          'c': 'f',
          'd': 'fb',
          'e': 'h',
          'f': 'ha',
          'g': 'h',
          'h': 'd',
          'i': 'da',
          'j': 'd',
          'k': 'ba',
          'l': 'baa',
          'm': 'ba',
          'n': 'ab',
          '|': '|',
}

desc_none = {
          '|': '|',
}

# Tammy now the problem is that the ending pipe is not doing its job.
# I'm not sure what's causing it.

table = {'|': desc_pipe,
         '.': desc_stop,
         '?': desc_orly,
         '!': desc_bang,
         ',': desc_coma,
         ';': desc_semi,
         '': desc_none,}

def knave_star(word: str):
    acc = ''
    for pair in pairwise(word):
        print(pair)
        val = bond[pair[0]]
        desc = table[val]
        acc += desc[pair[1]]
    return acc


def single(func, mode:str):
    helptext = {'Knave Map': 'Input a binary word.',
                'Knave* Map': 'Input a word using the letters a-n;'}
    prompt = {'Knave Map': 'Just zeroes and ones, thank you.\n',
              'Knave* Map': 'Exactly one of .?!,; may occur at the end of the word.\n'}
    adj = {'Knave Map': 'two-faced',
           'Knave* Map': 'star-eyed'}
    def dialogue():
        print(helptext[mode])
        word = input(prompt[mode])
        print()
        if mode == 'Knave* Map':
            word = '|' + word + '|'
        desc = func(word)
        print(f'The {adj[mode]} knave describes {word} as {desc}.')
    return dialogue


bits = {'|': '',
        '.': '1',
        '?': '11',
        '!': '111',       
        ',': '1111',
        ';': '11111',
        'a': '10',
        'b': '100',
        'c': '1000',
        'd': '10000',
        'e': '110',
        'f': '1100',
        'g': '11000',
        'h': '1110',
        'i': '11100',
        'j': '111000',
        'k': '11110',
        'l': '111100',
        'm': '1111000',
        'n': '111110',}

Stats_tuple = namedtuple('stats', ['zeroes', 'ones'], defaults=(0, 0))

# Tammy you also need to fix this.

counts = {'|': Stats_tuple(0, 0),
          'a': Stats_tuple(0, 1),
          'b': Stats_tuple(1, 1),
          'c': Stats_tuple(2, 1),
          'd': Stats_tuple(3, 1),
          'e': Stats_tuple(0, 2),
          'f': Stats_tuple(1, 2),
          'g': Stats_tuple(2, 2),
          'h': Stats_tuple(3, 2),
          'i': Stats_tuple(0, 3),
          'j': Stats_tuple(1, 3),          
          'k': Stats_tuple(2, 3),
          'l': Stats_tuple(3, 3),
          'm': Stats_tuple(1, 4),
          'n': Stats_tuple(2, 4),
          'p': Stats_tuple(3, 4),       
}

def stats(word):
    def stat_sum(acc:tuple, char:str):
        val = counts[char]
        return (acc[0] + val[0], acc[1] + val[1])

    if len(word) == 1:
        output = counts[word]
    else:
        output = (reduce(stat_sum, word, (0, 0)))
        output = Stats_tuple(*output)
    return output


def iterate_stats():
    in_word = input('Input a word using the letters a-m, p.\n')
    in_word = '|' + in_word + '|'
    n = int(input('How many iterations?\nn = '))
    queue = (knave_star for _ in range(n))
    multi = compose(*queue)
    out_word = multi(in_word)
    in_stats = stats(in_word)
    in_len = in_stats[0] + in_stats[1]
    in_density = in_stats[1] / in_len
    out_stats = stats(out_word)
    out_len = out_stats[0] + out_stats[1]
    out_density = out_stats[1] / out_len
    rate = pow(out_len/in_len, 1/n)
    print('')
    print(f'A party of {n} knaves depart with a word of bitlength {in_len} and density {in_density}.')
    print(f'They return with a word of bitlength {out_len} and density {out_density}.')
    print(f"The average knave extendeds the word's length by a factor of {rate}.\n")    


def print_dict():
    for key in bits.keys():
        print(f"'{key}' -> '{bits[key]}'")
    print()


action = {'Knave Map': single(knave, 'Knave Map'),
          'Knave* Map': single(knave_star, 'Knave* Map'),
          'Iterate w/ Stats': iterate_stats,
          'Translation Dicitionary': print_dict}


def again():
    val = pick('Choose another mode?', ('No', 'Yes'))
    return val == 'Yes'


def ciao():
    print('Ciao!')


def main():
    welcome()
    repeat = True
    while repeat:
        mode = set_mode()
        action[mode]()
        repeat = again()
    ciao()


if __name__ == '__main__':
    main()
